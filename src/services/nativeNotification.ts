import type { TNativeNotificationPartnerParams } from '@src/types/nativeNotificationParams';
import { Listing, User } from '@src/utils/data';
import { formatTimestamp } from '@src/utils/dates';
import {
  EBookerNativeNotificationType,
  ECompanyPermission,
  ENativeNotificationType,
} from '@src/utils/enums';
import type { TListing, TUser } from '@src/utils/types';

import { fetchUser } from './integrationHelper';
import { sendNotification } from './oneSignal';

type NativeNotificationParams = {
  order?: TListing;
  participantId: string;
  foodName?: string;
  planId?: string;
  subOrderDate?: string;
};
const BASE_URL = process.env.NEXT_PUBLIC_CANONICAL_URL;

export const createNativeNotification = async (
  notificationType: ENativeNotificationType,
  notificationParams: NativeNotificationParams,
) => {
  const { participantId } = notificationParams;
  const participant = await fetchUser(participantId);
  const participantUser = User(participant);
  const { firstName } = participantUser.getProfile();
  const { oneSignalUserIds = [] } = participantUser.getPrivateData();
  const { company, isCompany } = participantUser.getMetadata();

  const isBooker = Object.values(company).some(({ permission }: any) => {
    return permission === ECompanyPermission.booker;
  });

  const notSendParticipantNotification = isCompany || isBooker;

  if (notSendParticipantNotification) return;

  if (oneSignalUserIds.length === 0) return;

  switch (notificationType) {
    case ENativeNotificationType.BookerTransitOrderStateToPicking:
      {
        const { order } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { startDate, endDate } = orderListing.getMetadata();
        const url = `${BASE_URL}/participant/order/${orderId}/?subOrderDate=${startDate}&viewMode=week`;
        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `B·∫°n mu·ªën ƒÉn g√¨ n√†o ü§î ?`,
            content: `Tu·∫ßn ƒÉn ${formatTimestamp(
              +startDate,
              'dd/MM',
            )}-${formatTimestamp(
              +endDate,
              'dd/MM',
            )} ƒë√£ s·∫µn s√†ng, m·ªùi ${firstName} ch·ªçn m√≥n nh√©!`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;
    case ENativeNotificationType.BookerTransitOrderStateToInProgress:
      {
        const { order } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { startDate, endDate } = orderListing.getMetadata();
        const url = `${BASE_URL}/participant/order/${orderId}/?subOrderDate=${startDate}&viewMode=week`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: 'Tu·∫ßn ƒÉn ƒë√£ ƒë·∫∑t',
            content: `Tu·∫ßn ƒÉn ${formatTimestamp(
              +startDate,
              'dd/MM',
            )}-${formatTimestamp(
              +endDate,
              'dd/MM',
            )} c·ªßa ${firstName} ƒë∆∞·ª£c ƒë·∫∑t th√†nh c√¥ng`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;
    case ENativeNotificationType.AdminTransitSubOrderToDelivering:
      {
        const { foodName, planId, subOrderDate } = notificationParams;
        const url = `${BASE_URL}/participant/orders/?planId=${planId}&timestamp=${subOrderDate}&viewMode=week`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: 'üõµ üõµ üõµ C∆°m s·∫Øp ƒë·∫øn',
            content: `üåü ${foodName} s·∫Øp ƒë·∫øn r·ªìi. Chu·∫©n b·ªã ƒÉn th√¥i`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;
    case ENativeNotificationType.AdminTransitSubOrderToDelivered:
      {
        const { foodName, planId, subOrderDate } = notificationParams;
        const url = `${BASE_URL}/participant/orders/?planId=${planId}&timestamp=${subOrderDate}&viewMode=week`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: 'ƒê√£ c√≥ c∆°m üòç üòç üòç',
            content: `${foodName} ƒë√£ ƒë∆∞·ª£c giao ƒë·∫øn b·∫°n. Ch√∫c ${firstName} ngon mi·ªáng.`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;
    case ENativeNotificationType.AdminTransitSubOrderToCanceled:
      {
        const { planId, subOrderDate } = notificationParams;
        const url = `${BASE_URL}/participant/orders/?planId=${planId}&timestamp=${subOrderDate}&viewMode=week`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: 'Opps! Ng√†y ƒÉn b·ªã h·ªßy!',
            content: `üò¢ ${firstName} ∆°i, r·∫•t ti·∫øc ph·∫£i th√¥ng b√°o ng√†y ƒÉn ${formatTimestamp(
              +subOrderDate!,
              'dd/MM',
            )} ƒë√£ b·ªã h·ªßy`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;
    case ENativeNotificationType.TransitOrderStateToCanceled:
      {
        const { order, planId } = notificationParams;
        const orderListing = Listing(order!);
        const { startDate, endDate } = orderListing.getMetadata();
        const url = `${BASE_URL}/participant/orders/?planId=${planId}&timestamp=${startDate}&viewMode=week`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: 'Opps! Tu·∫ßn ƒÉn b·ªã h·ªßy!',
            content: `üò¢ ${firstName} ∆°i, r·∫•t ti·∫øc ph·∫£i th√¥ng b√°o tu·∫ßn ƒÉn ${formatTimestamp(
              +startDate!,
              'dd/MM',
            )}-${formatTimestamp(+endDate!, 'dd/MM')} ƒë√£ b·ªã h·ªßy`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    default:
      break;
  }
};

export const createNativeNotificationToPartner = async (
  notificationType: ENativeNotificationType,
  notificationParams: TNativeNotificationPartnerParams,
) => {
  const { partner } = notificationParams;
  const partnerUser = User(partner);
  const { isPartner } = partnerUser.getMetadata();
  if (!isPartner) return;
  const { oneSignalUserIds = [] } = partnerUser.getPrivateData();

  if (oneSignalUserIds.length === 0) return;

  switch (notificationType) {
    case ENativeNotificationType.BookerTransitOrderStateToInProgress:
      {
        const { order, subOrderDate } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { deliveryHour } = orderListing.getMetadata();
        const deliveryStartHour = deliveryHour.split('-')[0];
        const url = `${BASE_URL}/partner/orders/${orderId}_${subOrderDate}`;

        const oneSingals: Promise<any>[] = [];
        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          oneSingals.push(
            sendNotification({
              title: 'üòçB·∫°n c√≥ m·ªôt ƒë∆°n h√†ng m·ªõi!',
              content: `B·∫°n c√≥ ƒë∆°n h√†ng c·∫ßn tri·ªÉn khai v√†o ${deliveryStartHour}, ${formatTimestamp(
                +subOrderDate!,
                'dd/MM/yyyy',
              )}. Nh·∫•n ƒë·ªÉ x√°c nh·∫≠n ƒë∆°n.`,
              url,
              oneSignalUserId,
            }),
          );
        });

        await Promise.allSettled(oneSingals);
      }
      break;

    case ENativeNotificationType.TransitOrderStateToCanceled:
    case ENativeNotificationType.AdminTransitSubOrderToCanceled:
      {
        const { order, subOrderDate } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { deliveryHour } = orderListing.getMetadata();
        const deliveryStartHour = deliveryHour.split('-')[0];
        const url = `${BASE_URL}/partner/orders/${orderId}_${subOrderDate}`;

        const oneSingals: Promise<any>[] = [];
        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          oneSingals.push(
            sendNotification({
              title: 'üò¢R·∫•t ti·∫øc! M·ªôt ƒë∆°n h√†ng v·ª´a b·ªã hu·ª∑!',
              content: `ƒê∆°n h√†ng v√†o l√∫c ${deliveryStartHour}, ${formatTimestamp(
                +subOrderDate!,
                'dd/MM/yyyy',
              )} v·ª´a b·ªã hu·ª∑. Nh·∫•n ƒë·ªÉ xem chi ti·∫øt.`,
              url,
              oneSignalUserId,
            }),
          );
        });
        await Promise.allSettled(oneSingals);
      }
      break;
    case ENativeNotificationType.AdminUpdateOrder:
      {
        const { order, subOrderDate } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { deliveryHour } = orderListing.getMetadata();
        const deliveryStartHour = deliveryHour.split('-')[0];
        const url = `${BASE_URL}/partner/orders/${orderId}_${subOrderDate}`;

        const oneSingals: Promise<any>[] = [];
        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          oneSingals.push(
            sendNotification({
              title: 'ƒê∆°n h√†ng c√≥ s·ª± thay ƒë·ªïi!',
              content: `ƒê∆°n h√†ng v√†o l√∫c ${deliveryStartHour}, ${formatTimestamp(
                +subOrderDate!,
                'dd/MM/yyyy',
              )} v·ª´a ƒë∆∞·ª£c ch·ªânh s·ª≠a. Nh·∫•n ƒë·ªÉ c·∫≠p nh·∫≠t chi ti·∫øt.`,
              url,
              oneSignalUserId,
            }),
          );
        });
        await Promise.allSettled(oneSingals);
      }
      break;
    case ENativeNotificationType.AdminTransitFoodStateToApprove:
      {
        const { foodId, foodName } = notificationParams;
        const url = `${BASE_URL}/partner/products/food/${foodId}/?fromTab=accepted`;

        const oneSingals: Promise<any>[] = [];
        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          oneSingals.push(
            sendNotification({
              title: 'üòçüòçTuy·ªát v·ªùi! M√≥n ƒÉn ƒë√£ ƒë∆∞·ª£c duy·ªát!',
              content: `M√≥n ƒÉn ${foodName} ƒë√£ ƒë∆∞·ª£c duy·ªát. Nh·∫•n v√†o ƒë·ªÉ xem chi ti·∫øt`,
              url,
              oneSignalUserId,
            }),
          );
        });
        await Promise.allSettled(oneSingals);
      }
      break;
    case ENativeNotificationType.AdminTransitFoodStateToReject:
      {
        const { foodId, foodName } = notificationParams;
        const url = `${BASE_URL}/partner/products/food/${foodId}/?fromTab=accepted`;

        const oneSingals: Promise<any>[] = [];
        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          oneSingals.push(
            sendNotification({
              title: 'üò¢Opps! M√≥n ƒÉn b·ªã t·ª´ ch·ªëi duy·ªát!',
              content: `R·∫•t ti·∫øc, m√≥n ${foodName} b·ªã t·ª´ ch·ªëi duy·ªát. Nh·∫•n v√†o ƒë·ªÉ xem l√Ω do!`,
              url,
              oneSignalUserId,
            }),
          );
        });
        await Promise.allSettled(oneSingals);
      }
      break;
    case ENativeNotificationType.AdminChangePartnerInformation:
      {
        const { partnerName } = notificationParams;

        const url = `${BASE_URL}/partner/settings/account/info`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `Th√¥ng tin ${partnerName} ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a`,
            content: `Th√¥ng tin th∆∞∆°ng hi·ªáu c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a. Nh·∫•n ƒë·ªÉ xem chi ti·∫øt.`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    case ENativeNotificationType.PartnerSubOrderNegativeRating:
      {
        const { subOrderDate } = notificationParams;
        const url = `${BASE_URL}/partner/reviews?rating=1,2`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: 'üò¢ B·∫°n v·ª´a nh·∫≠n ƒë∆∞·ª£c m·ªôt ƒë√°nh gi√° ti√™u c·ª±c',
            content: `ƒê∆°n h√†ng ng√†y ${formatTimestamp(
              +subOrderDate!,
              'dd/MM/yyyy',
            )} v·ª´a nh·∫≠n ƒë∆∞·ª£c m·ªôt ƒë√°nh gi√° ti√™u c·ª±c t·ª´ kh√°ch h√†ng. Nh·∫•n ƒë·ªÉ xem chi ti·∫øt!`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    default:
      break;
  }
};

type NativeNotificationBookerParams = {
  booker: TUser;
  order?: TListing;
  subOrderDate?: string;
};

export const createNativeNotificationToBooker = async (
  notificationType: EBookerNativeNotificationType,
  notificationParams: NativeNotificationBookerParams,
) => {
  const { booker } = notificationParams;
  const bookerUser = User(booker);
  const { isCompany, company } = bookerUser.getMetadata();
  const { firstName, lastName } = bookerUser.getProfile();
  const bookerName = `${lastName} ${firstName}`;
  const isBooker = Object.values(company).some(({ permission }: any) => {
    return permission === ECompanyPermission.booker;
  });

  if (!isCompany && !isBooker) return;

  const { oneSignalUserIds = [] } = bookerUser.getPrivateData();

  if (oneSignalUserIds.length === 0) return;

  switch (notificationType) {
    case EBookerNativeNotificationType.AdminCreateNewOrder:
      {
        const { order } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();

        const url = `${BASE_URL}/company/booker/orders/draft/${orderId}?userRole=booker`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `C√≥ ƒë∆°n h√†ng m·ªõi ‚ú®`,
            content:
              'Ting ting! B·∫°n v·ª´a nh·∫≠n ƒë∆∞·ª£c m·ªôt ƒë∆°n h√†ng m·ªõi t·∫°o b·ªüi PITO',
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    case EBookerNativeNotificationType.AdminStartOrder:
      {
        const { order } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { startDate, endDate } = orderListing.getMetadata();

        const url = `${BASE_URL}/company/orders/${orderId}?userRole=booker`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `Tu·∫ßn ƒÉn ƒë√£ ƒë·∫∑t üåü`,
            content: `Tu·∫ßn ƒÉn ${formatTimestamp(
              startDate,
              'dd/MM',
            )} -${formatTimestamp(endDate, 'dd/MM')} ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh c√¥ng.`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    case EBookerNativeNotificationType.SubOrderCancelled:
      {
        const { order, subOrderDate } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();

        const url = `${BASE_URL}/company/orders/${orderId}?userRole=booker`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `Opps! Ng√†y ƒÉn b·ªã h·ªßy! üò¢`,
            content: `${bookerName} ∆°i, r·∫•t ti·∫øc ph·∫£i th√¥ng b√°o ng√†y ƒÉn ${formatTimestamp(
              +subOrderDate!,
              'dd/MM',
            )} ƒë√£ b·ªã h·ªßy`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    case EBookerNativeNotificationType.SubOrderDelivering:
      {
        const { order, subOrderDate } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();

        const url = `${BASE_URL}/company/orders/${orderId}?userRole=booker`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `C∆°m s·∫Øp ƒë·∫øn üöö`,
            content: `Ng√†y ƒÉn ${formatTimestamp(
              +subOrderDate!,
              'dd/MM',
            )} s·∫Øp ƒë·∫øn r·ªìi. Chu·∫©n b·ªã ƒÉn th√¥i!!`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    case EBookerNativeNotificationType.SubOrderDelivered:
      {
        const { order, subOrderDate } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();

        const url = `${BASE_URL}/company/orders/${orderId}?userRole=booker`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `ƒê√£ c√≥ c∆°m üòç`,
            content: `Ng√†y ƒÉn ${formatTimestamp(
              +subOrderDate!,
              'dd/MM',
            )} ƒë√£ ƒë∆∞·ª£c giao ƒë·∫øn b·∫°n. Ch√∫c ${bookerName} v√† ƒë·ªìng nghi·ªáp c√≥ m·ªôt b·ªØa ƒÉn ngon mi·ªáng.`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    case EBookerNativeNotificationType.OrderIsPendingPayment:
      {
        const { order } = notificationParams;
        const orderListing = Listing(order!);
        const orderId = orderListing.getId();
        const { startDate, endDate } = orderListing.getMetadata();

        const url = `${BASE_URL}/company/orders/${orderId}/rating?userRole=booker`;

        oneSignalUserIds.forEach((oneSignalUserId: string) => {
          sendNotification({
            title: `ƒê√°nh gi√° tu·∫ßn ƒÉn üåü`,
            content: `${bookerName} ∆°i, b·∫°n ƒë√°nh gi√° tu·∫ßn ƒÉn ${formatTimestamp(
              startDate,
              'dd/MM',
            )} -${formatTimestamp(endDate, 'dd/MM')} m·∫•y ƒëi·ªÉm?`,
            url,
            oneSignalUserId,
          });
        });
      }
      break;

    default:
      break;
  }
};
